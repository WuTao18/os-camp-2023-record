#+title: 第一阶段训练学习记录
#+author: Tao Wu
#+email: taowuuwoat@outlook.com

* 实验记录 [2023-03-31 Fri 00:29]
#+BEGIN: clocktable :scope subtree :maxlevel 4
#+CAPTION: Clock summary at [2023-04-01 Sat 02:21]
| Headline                                        | Time   |   |      |      |
|-------------------------------------------------+--------+---+------+------|
| *Total time*                                    | *2:04* |   |      |      |
|-------------------------------------------------+--------+---+------+------|
| \_    实验记录 [2023-03-31 Fri 00:29]           |        |   | 2:04 |      |
| \_      环境准备 [2023-03-31 Fri 00:29]         |        |   |      | 0:22 |
| \_      intro [2023-03-31 Fri 23:29]           |        |   |      | 0:05 |
| \_      variables [2023-03-31 Fri 00:36]       |        |   |      | 0:05 |
| \_      functions [2023-03-31 Fri 23:49]       |        |   |      | 0:06 |
| \_      if [2023-04-01 Sat 00:01]              |        |   |      | 0:03 |
| \_      quiz1 [2023-04-01 Sat 00:05]           |        |   |      | 0:03 |
| \_      primitive_types [2023-04-01 Sat 00:09] |        |   |      | 0:05 |
| \_      vecs [2023-04-01 Sat 00:18]            |        |   |      | 0:02 |
| \_      move_semantics [2023-04-01 Sat 00:23]  |        |   |      | 0:09 |
| \_      structs [2023-04-01 Sat 00:35]         |        |   |      | 0:11 |
| \_      enums [2023-04-01 Sat 00:58]           |        |   |      | 0:07 |
| \_      strings [2023-04-01 Sat 01:10]         |        |   |      | 0:09 |
| \_      modules [2023-04-01 Sat 01:21]         |        |   |      | 0:03 |
| \_      hashmaps [2023-04-01 Sat 01:28]        |        |   |      | 0:16 |
| \_      quiz2 [2023-04-01 Sat 01:57]           |        |   |      | 0:18 |
#+END:

** 环境准备 [2023-03-31 Fri 00:29]
:LOGBOOK:
CLOCK: [2023-03-31 Fri 22:45]--[2023-03-31 Fri 23:07] =>  0:22
:END:
*** Emacs (Doom Emacs) + WSL (WSL2 + WSLg) [2023-03-31 Fri 22:49]
**** Emacs 用于开发 + 笔记 + 时间/任务管理
**** LSP 采用 [[https://rust-analyzer.github.io/][rust-analyzer]]，代码格式化采用 [[https://github.com/rust-lang/rustfmt][rustfmt]]
**** 笔记，任务管理和文学编程使用 [[https://orgmode.org/][org mode]]
**** WSL 采用 [[https://github.com/yuk7/ArchWSL][Arch Linux]]
*** rustlings 采用本地开发 [2023-03-31 Fri 22:56]
**** clone github classroom 生成的 repo 到本地
**** 进入仓库，运行 =cargo install --force --path .=
**** 把 =~/.cargo/bin= 加入到 =$PATH= [2023-03-31 Fri 23:07]
** DONE intro [2023-03-31 Fri 23:29]
:LOGBOOK:
CLOCK: [2023-03-31 Fri 23:29]--[2023-03-31 Fri 23:34] =>  0:05
:END:
*** intro1
#+begin_src rust
// intro1.rs
// About this `I AM NOT DONE` thing:
// We sometimes encourage you to keep trying things on a given exercise, even
// after you already figured it out. If you got everything working and feel
// ready for the next exercise, remove the `I AM NOT DONE` comment below.
// Execute `rustlings hint intro1` or use the `hint` watch subcommand for a hint.
//
// If you're running this using `rustlings watch`: The exercise file will be reloaded
// when you change one of the lines below! Try adding a `println!` line, or try changing
// what it outputs in your terminal. Try removing a semicolon and see what happens!


fn main() {
    println!("Hello and");
    println!(r#"       welcome to...                      "#);
    println!(r#"                 _   _ _                  "#);
    println!(r#"  _ __ _   _ ___| |_| (_)_ __   __ _ ___  "#);
    println!(r#" | '__| | | / __| __| | | '_ \ / _` / __| "#);
    println!(r#" | |  | |_| \__ \ |_| | | | | | (_| \__ \ "#);
    println!(r#" |_|   \__,_|___/\__|_|_|_| |_|\__, |___/ "#);
    println!(r#"                               |___/      "#);
    println!();
    println!("This exercise compiles successfully. The remaining exercises contain a compiler");
    println!("or logic error. The central concept behind Rustlings is to fix these errors and");
    println!("solve the exercises. Good luck!");
    println!();
    println!("The source for this exercise is in `exercises/intro/intro1.rs`. Have a look!");
    println!("Going forward, the source of the exercises will always be in the success/failure output.");
}
#+end_src

#+RESULTS:
#+begin_example
Hello and
       welcome to...
                 _   _ _
  _ __ _   _ ___| |_| (_)_ __   __ _ ___
 | '__| | | / __| __| | | '_ \ / _` / __|
 | |  | |_| \__ \ |_| | | | | | (_| \__ \
 |_|   \__,_|___/\__|_|_|_| |_|\__, |___/
                               |___/

This exercise compiles successfully. The remaining exercises contain a compiler
or logic error. The central concept behind Rustlings is to fix these errors and
solve the exercises. Good luck!

The source for this exercise is in `exercises/intro/intro1.rs`. Have a look!
Going forward, the source of the exercises will always be in the success/failure output.
#+end_example
*** intro2
#+begin_src rust
// intro2.rs
// Make the code print a greeting to the world.
// Execute `rustlings hint intro2` or use the `hint` watch subcommand for a hint.


fn main() {
    println!("Hello {}!", "world");
}
#+end_src

#+RESULTS:
: Hello world!

** DONE variables [2023-03-31 Fri 00:36]
:LOGBOOK:
CLOCK: [2023-03-31 Fri 23:36]--[2023-03-31 Fri 23:41] =>  0:05
:END:
看了一眼题目，感觉有点熟悉，不久前刷过 rust 习题，看了一下，是 rust-by-practice
*** variables1
#+begin_src rust
// variables1.rs
// Make me compile!
// Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.


fn main() {
    let x = 5;
    println!("x has the value {}", x);
}
#+end_src

#+RESULTS:
: x has the value 5

*** variables2
#+begin_src rust
// variables2.rs
// Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.


fn main() {
    let x = 10;
    if x == 10 {
        println!("x is ten!");
    } else {
        println!("x is not ten!");
    }
}
#+end_src

#+RESULTS:
: x is ten!

*** variables3
#+begin_src rust
// variables3.rs
// Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.


fn main() {
    let x: i32 = 0;
    println!("Number {}", x);
}
#+end_src

#+RESULTS:
: Number 0

*** variables4
#+begin_src rust
// variables4.rs
// Execute `rustlings hint variables4` or use the `hint` watch subcommand for a hint.


fn main() {
    let mut x = 3;
    println!("Number {}", x);
    x = 5; // don't change this line
    println!("Number {}", x);
}
#+end_src

#+RESULTS:
: Number 3
: Number 5

*** variables5
#+begin_src rust
// variables5.rs
// Execute `rustlings hint variables5` or use the `hint` watch subcommand for a hint.


fn main() {
    let number = "T-H-R-E-E"; // don't change this line
    println!("Spell a Number : {}", number);
    let number;
    number = 3; // don't rename this variable
    println!("Number plus two is : {}", number + 2);
}
#+end_src

#+RESULTS:
: Spell a Number : T-H-R-E-E
: Number plus two is : 5

*** variables6
常量需要指定类型。
#+begin_src rust
// variables6.rs
// Execute `rustlings hint variables6` or use the `hint` watch subcommand for a hint.


const NUMBER: i32 = 3;
fn main() {
    println!("Number {}", NUMBER);
}
#+end_src

#+RESULTS:
: Number 3
** DONE functions [2023-03-31 Fri 23:49]
:LOGBOOK:
CLOCK: [2023-03-31 Fri 23:49]--[2023-03-31 Fri 23:55] =>  0:06
:END:
*** functions1
#+begin_src rust
// functions1.rs
// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

fn call_me() {}

fn main() {
    call_me();
}
#+end_src

#+RESULTS:

*** functions2
#+begin_src rust
// functions2.rs
// Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.


fn main() {
    call_me(3);
}

fn call_me(num: usize) {
    for i in 0..num {
        println!("Ring! Call number {}", i + 1);
    }
}
#+end_src

#+RESULTS:
: Ring! Call number 1
: Ring! Call number 2
: Ring! Call number 3

*** functions3
#+begin_src rust
// functions3.rs
// execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.


fn main() {
    call_me(3);
}

fn call_me(num: u32) {
    for i in 0..num {
        println!("ring! call number {}", i + 1);
    }
}
#+end_src

#+results:
: ring! call number 1
: ring! call number 2
: ring! call number 3

*** functions4
#+begin_src rust
// functions4.rs
// Execute `rustlings hint functions4` or use the `hint` watch subcommand for a hint.

// This store is having a sale where if the price is an even number, you get
// 10 Rustbucks off, but if it's an odd number, it's 3 Rustbucks off.
// (Don't worry about the function bodies themselves, we're only interested
// in the signatures for now. If anything, this is a good way to peek ahead
// to future exercises!)


fn main() {
    let original_price = 51;
    println!("Your sale price is {}", sale_price(original_price));
}

fn sale_price(price: i32) -> i32 {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn is_even(num: i32) -> bool {
    num % 2 == 0
}
#+end_src

#+RESULTS:
: Your sale price is 48

*** functions5
#+begin_src rust
// functions5.rs
// Execute `rustlings hint functions5` or use the `hint` watch subcommand for a hint.


fn main() {
    let answer = square(3);
    println!("The square of 3 is {}", answer);
}

fn square(num: i32) -> i32 {
    num * num
}
#+end_src

#+RESULTS:
: The square of 3 is 9

** DONE if [2023-04-01 Sat 00:01]
:LOGBOOK:
CLOCK: [2023-04-01 Sat 00:01]--[2023-04-01 Sat 00:04] =>  0:03
:END:
*** if1
#+begin_src rust
// if1.rs
// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.


pub fn bigger(a: i32, b: i32) -> i32 {
    // Complete this function to return the bigger number!
    // Do not use:
    // - another function call
    // - additional variables
    if a > b {
        10
    } else {
        42
    }
}

// Don't mind this for now :)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ten_is_bigger_than_eight() {
        assert_eq!(10, bigger(10, 8));
    }

    #[test]
    fn fortytwo_is_bigger_than_thirtytwo() {
        assert_eq!(42, bigger(32, 42));
    }
}
#+end_src

#+RESULTS:

*** if2
#+begin_src rust
// if2.rs

// Step 1: Make me compile!
// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!
// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.


pub fn foo_if_fizz(fizzish: &str) -> &str {
    if fizzish == "fizz" {
        "foo"
    } else if fizzish == "fuzz" {
        "bar"
    } else {
        "baz"
    }
}

// No test changes needed!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz("fizz"), "foo")
    }

    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz("fuzz"), "bar")
    }

    #[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz("literally anything"), "baz")
    }
}
#+end_src

#+RESULTS:

** DONE quiz1 [2023-04-01 Sat 00:05]
:LOGBOOK:
CLOCK: [2023-04-01 Sat 00:05]--[2023-04-01 Sat 00:08] =>  0:03
:END:
#+begin_src rust
// quiz1.rs
// This is a quiz for the following sections:
// - Variables
// - Functions
// - If

// Mary is buying apples. The price of an apple is calculated as follows:
// - An apple costs 2 rustbucks.
// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!
// Write a function that calculates the price of an order of apples given
// the quantity bought. No hints this time!


// Put your function here!
// fn calculate_price_of_apples {
fn calculate_price_of_apples(apples: u32) -> u32 {
    if apples > 40 {
        apples
    } else {
        apples * 2
    }
}

// Don't modify this function!
#[test]
fn verify_test() {
    let price1 = calculate_price_of_apples(35);
    let price2 = calculate_price_of_apples(40);
    let price3 = calculate_price_of_apples(41);
    let price4 = calculate_price_of_apples(65);

    assert_eq!(70, price1);
    assert_eq!(80, price2);
    assert_eq!(41, price3);
    assert_eq!(65, price4);
}
#+end_src

#+RESULTS:

** DONE primitive_types [2023-04-01 Sat 00:09]
:LOGBOOK:
CLOCK: [2023-04-01 Sat 00:09]--[2023-04-01 Sat 00:14] =>  0:05
:END:
*** primitive_types1
#+begin_src rust
// primitive_types1.rs
// Fill in the rest of the line that has code missing!
// No hints, there's no tricks, just get used to typing these :)


fn main() {
    // Booleans (`bool`)

    let is_morning = true;
    if is_morning {
        println!("Good morning!");
    }

    let is_evening = false; // Finish the rest of this line like the example! Or make it be false!
    if is_evening {
        println!("Good evening!");
    }
}
#+end_src

#+RESULTS:
: Good morning!

*** primitive_types2
#+begin_src rust
// primitive_types2.rs
// Fill in the rest of the line that has code missing!
// No hints, there's no tricks, just get used to typing these :)


fn main() {
    // Characters (`char`)

    // Note the _single_ quotes, these are different from the double quotes
    // you've been seeing around.
    let my_first_initial = 'C';
    if my_first_initial.is_alphabetic() {
        println!("Alphabetical!");
    } else if my_first_initial.is_numeric() {
        println!("Numerical!");
    } else {
        println!("Neither alphabetic nor numeric!");
    }

    let your_character = '涛'; // Finish this line like the example! What's your favorite character?
    // Try a letter, try a number, try a special character, try a character
    // from a different language than your own, try an emoji!
    if your_character.is_alphabetic() {
        println!("Alphabetical!");
    } else if your_character.is_numeric() {
        println!("Numerical!");
    } else {
        println!("Neither alphabetic nor numeric!");
    }
}
#+end_src

#+RESULTS:
: Alphabetical!
: Alphabetical!

*** primitive_types3
#+begin_src rust
// primitive_types3.rs
// Create an array with at least 100 elements in it where the ??? is.
// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.


fn main() {
    let a = [0; 110];

    if a.len() >= 100 {
        println!("Wow, that's a big array!");
    } else {
        println!("Meh, I eat arrays like that for breakfast.");
    }
}
#+end_src

#+RESULTS:
: Wow, that's a big array!

*** primitive_types4
#+begin_src rust
// primitive_types4.rs
// Get a slice out of Array a where the ??? is so that the test passes.
// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.


#[test]
fn slice_out_of_array() {
    let a = [1, 2, 3, 4, 5];

    let nice_slice = &a[1..4];

    assert_eq!([2, 3, 4], nice_slice)
}
#+end_src

#+RESULTS:

*** primitive_types5
#+begin_src rust
// primitive_types5.rs
// Destructure the `cat` tuple so that the println will work.
// Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.


fn main() {
    let cat = ("Furry McFurson", 3.5);
    let (name, age) /* your pattern here */ = cat;

    println!("{} is {} years old.", name, age);
}
#+end_src

#+RESULTS:
: Furry McFurson is 3.5 years old.

*** primitive_types6
#+begin_src rust
// primitive_types6.rs
// Use a tuple index to access the second element of `numbers`.
// You can put the expression for the second element where ??? is so that the test passes.
// Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.


#[test]
fn indexing_tuple() {
    let numbers = (1, 2, 3);
    // Replace below ??? with the tuple indexing syntax.
    let second = numbers.1;

    assert_eq!(2, second,
        "This is not the 2nd number in the tuple!")
}
#+end_src

#+RESULTS:

** DONE vecs [2023-04-01 Sat 00:18]
:LOGBOOK:
CLOCK: [2023-04-01 Sat 00:19]--[2023-04-01 Sat 00:21] =>  0:02
:END:
*** vecs1
#+begin_src rust
// vecs1.rs
// Your task is to create a `Vec` which holds the exact same elements
// as in the array `a`.
// Make me compile and pass the test!
// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.


fn array_and_vec() -> ([i32; 4], Vec<i32>) {
    let a = [10, 20, 30, 40]; // a plain array
    let v = a.clone().to_vec(); // TODO: declare your vector here with the macro for vectors

    (a, v)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, v[..]);
    }
}
#+end_src

#+RESULTS:

*** vecs2
#+begin_src rust
// vecs2.rs
// A Vec of even numbers is given. Your task is to complete the loop
// so that each number in the Vec is multiplied by 2.
//
// Make me pass the test!
//
// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.


fn vec_loop(mut v: Vec<i32>) -> Vec<i32> {
    for i in v.iter_mut() {
        // TODO: Fill this up so that each element in the Vec `v` is
        // multiplied by 2.
        *i *= 2;
    }

    // At this point, `v` should be equal to [4, 8, 12, 16, 20].
    v
}

fn vec_map(v: &Vec<i32>) -> Vec<i32> {
    v.iter().map(|num| {
        // TODO: Do the same thing as above - but instead of mutating the
        // Vec, you can just return the new number!
        num * 2
    }).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_loop(v.clone());

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());
    }

    #[test]
    fn test_vec_map() {
        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_map(&v);

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());
    }
}
#+end_src

#+RESULTS:
** DONE move_semantics [2023-04-01 Sat 00:23]
:LOGBOOK:
CLOCK: [2023-04-01 Sat 00:23]--[2023-04-01 Sat 00:32] =>  0:09
:END:
*** move_semantics1
#+begin_src rust
// move_semantics1.rs
// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.


fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
#+end_src

#+RESULTS:
: vec1 has length 3 content `[22, 44, 66]`
: vec1 has length 4 content `[22, 44, 66, 88]`

*** move_semantics2
#+begin_src rust
// move_semantics2.rs
// Make me compile without changing line 13 or moving line 10!
// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.


fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0.clone());

    // Do not change the following line!
    println!("{} has length {} content `{:?}`", "vec0", vec0.len(), vec0);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
#+end_src

#+RESULTS:
: vec0 has length 0 content `[]`
: vec1 has length 4 content `[22, 44, 66, 88]`

*** move_semantics3
#+begin_src rust
// move_semantics3.rs
// Make me compile without adding new lines-- just changing existing lines!
// (no lines with multiple semicolons necessary!)
// Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.


fn main() {
    let mut vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(mut vec: Vec<i32>) -> Vec<i32> {
    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
#+end_src

#+RESULTS:
: vec1 has length 3 content `[22, 44, 66]`
: vec1 has length 4 content `[22, 44, 66, 88]`

*** move_semantics4
#+begin_src rust
// move_semantics4.rs
// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,
// the Vector gets created in the function itself and passed back to the main
// function.
// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.


fn main() {
    // let vec0 = Vec::new();

    let mut vec1 = fill_vec();

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

// `fill_vec()` no longer takes `vec: Vec<i32>` as argument
fn fill_vec() -> Vec<i32> {
    let mut vec = vec![];

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
#+end_src

#+RESULTS:
: vec1 has length 3 content `[22, 44, 66]`
: vec1 has length 4 content `[22, 44, 66, 88]`

*** move_semantics5
#+begin_src rust
// move_semantics5.rs
// Make me compile only by reordering the lines in `main()`, but without
// adding, changing or removing any of them.
// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.


fn main() {
    let mut x = 100;
    let y = &mut x;
    *y += 100;
    let z = &mut x;
    *z += 1000;
    assert_eq!(x, 1200);
}
#+end_src

#+RESULTS:

*** move_semantics6
#+begin_src rust
// move_semantics6.rs
// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.
// You can't change anything except adding or removing references.


fn main() {
    let data = "Rust is great!".to_string();

    get_char(&data);

    string_uppercase(data);
}

// Should not take ownership
fn get_char(data: &String) -> char {
    data.chars().last().unwrap()
}

// Should take ownership
fn string_uppercase(mut data: String) {
    data = data.to_uppercase();

    println!("{}", data);
}
#+end_src

#+RESULTS:
: RUST IS GREAT!

** DONE structs [2023-04-01 Sat 00:35]
:LOGBOOK:
CLOCK: [2023-04-01 Sat 00:35]--[2023-04-01 Sat 00:46] =>  0:11
:END:
*** structs1
#+begin_src rust
// structs1.rs
// Address all the TODOs to make the tests pass!
// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.


struct ColorClassicStruct {
    // TODO: Something goes here
    red: u8,
    green: u8,
    blue: u8,
}

struct ColorTupleStruct(/* TODO: Something goes here */u8, u8, u8);

#[derive(Debug)]
struct UnitLikeStruct;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn classic_c_structs() {
        // TODO: Instantiate a classic c struct!
        // let green =
        let green = ColorClassicStruct {
            red: 0,
            green: 255,
            blue: 0,
        };

        assert_eq!(green.red, 0);
        assert_eq!(green.green, 255);
        assert_eq!(green.blue, 0);
    }

    #[test]
    fn tuple_structs() {
        // TODO: Instantiate a tuple struct!
        // let green =
        let green = ColorTupleStruct(0, 255, 0);

        assert_eq!(green.0, 0);
        assert_eq!(green.1, 255);
        assert_eq!(green.2, 0);
    }

    #[test]
    fn unit_structs() {
        // TODO: Instantiate a unit-like struct!
        // let unit_like_struct =
        let unit_like_struct = UnitLikeStruct;
        let message = format!("{:?}s are fun!", unit_like_struct);

        assert_eq!(message, "UnitLikeStructs are fun!");
    }
}
#+end_src

#+RESULTS:

*** structs2
#+begin_src rust
// structs2.rs
// Address all the TODOs to make the tests pass!
// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.


#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -> Order {
    Order {
        name: String::from("Bob"),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        // TODO: Create your own order using the update syntax and template above!
        // let your_order =
        let your_order = Order {
            name: "Hacker in Rust".to_string(),
            year: order_template.year,
            made_by_phone: order_template.made_by_phone,
            made_by_mobile: order_template.made_by_mobile,
            made_by_email: order_template.made_by_email,
            item_number: order_template.item_number,
            count: 1,
        };
        assert_eq!(your_order.name, "Hacker in Rust");
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}
#+end_src

#+RESULTS:

*** structs3
#+begin_src rust
// structs3.rs
// Structs contain data, but can also have logic. In this exercise we have
// defined the Package struct and we want to test some logic attached to it.
// Make the code compile and the tests pass!
// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.


#[derive(Debug)]
struct Package {
    sender_country: String,
    recipient_country: String,
    weight_in_grams: i32,
}

impl Package {
    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {
        if weight_in_grams <= 0 {
            panic!("Can not ship a weightless package.")
        } else {
            Package {
                sender_country,
                recipient_country,
                weight_in_grams,
            }
        }
    }

    fn is_international(&self) -> bool {
        // Something goes here...
        self.sender_country != self.recipient_country
    }

    fn get_fees(&self, cents_per_gram: i32) -> i32 {
        // Something goes here...
        self.weight_in_grams * cents_per_gram
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn fail_creating_weightless_package() {
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Austria");

        Package::new(sender_country, recipient_country, -2210);
    }

    #[test]
    fn create_international_package() {
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Russia");

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(package.is_international());
    }

    #[test]
    fn create_local_package() {
        let sender_country = String::from("Canada");
        let recipient_country = sender_country.clone();

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(!package.is_international());
    }

    #[test]
    fn calculate_transport_fees() {
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Spain");

        let cents_per_gram = 3;

        let package = Package::new(sender_country, recipient_country, 1500);

        assert_eq!(package.get_fees(cents_per_gram), 4500);
        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);
    }
}
#+end_src

#+RESULTS:

** DONE enums [2023-04-01 Sat 00:58]
:LOGBOOK:
CLOCK: [2023-04-01 Sat 00:58]--[2023-04-01 Sat 01:05] =>  0:07
:END:
*** enums1
#+begin_src rust
// enums1.rs
// No hints this time! ;)


#[derive(Debug)]
enum Message {
    // TODO: define a few types of messages as used below
    ChangeColor,
    Echo,
    Move,
    Quit,
}

fn main() {
    println!("{:?}", Message::Quit);
    println!("{:?}", Message::Echo);
    println!("{:?}", Message::Move);
    println!("{:?}", Message::ChangeColor);
}
#+end_src

#+RESULTS:
: Quit
: Echo
: Move
: ChangeColor

*** enums2
#+begin_src rust
// enums2.rs
// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.


#[derive(Debug)]
enum Message {
    // TODO: define the different variants used below
    ChangeColor(u8, u8, u8),
    Echo(String),
    Move{x: i32, y: i32},
    Quit,
}

impl Message {
    fn call(&self) {
        println!("{:?}", &self);
    }
}

fn main() {
    let messages = [
        Message::Move { x: 10, y: 30 },
        Message::Echo(String::from("hello world")),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &messages {
        message.call();
    }
}
#+end_src

#+RESULTS:
: Move { x: 10, y: 30 }
: Echo("hello world")
: ChangeColor(200, 255, 255)
: Quit

*** enums3
#+begin_src rust
// enums3.rs
// Address all the TODOs to make the tests pass!
// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.


enum Message {
    // TODO: implement the message variant types based on their usage below
    ChangeColor((u8, u8, u8)),
    Echo(String),
    Move(Point),
    Quit,
}

struct Point {
    x: u8,
    y: u8,
}

struct State {
    color: (u8, u8, u8),
    position: Point,
    quit: bool,
}

impl State {
    fn change_color(&mut self, color: (u8, u8, u8)) {
        self.color = color;
    }

    fn quit(&mut self) {
        self.quit = true;
    }

    fn echo(&self, s: String) {
        println!("{}", s);
    }

    fn move_position(&mut self, p: Point) {
        self.position = p;
    }

    fn process(&mut self, message: Message) {
        // TODO: create a match expression to process the different message variants
        match message {
            Message::ChangeColor((r, g, b)) => {
                self.change_color((r, g, b));
            }
            Message::Echo(s) => {
                self.echo(s);
            }
            Message::Move(p) => {
                self.move_position(p);
            }
            Message::Quit => {
                self.quit();
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_message_call() {
        let mut state = State {
            quit: false,
            position: Point { x: 0, y: 0 },
            color: (0, 0, 0),
        };
        state.process(Message::ChangeColor((255, 0, 255)));
        state.process(Message::Echo(String::from("hello world")));
        state.process(Message::Move(Point { x: 10, y: 15 }));
        state.process(Message::Quit);

        assert_eq!(state.color, (255, 0, 255));
        assert_eq!(state.position.x, 10);
        assert_eq!(state.position.y, 15);
        assert_eq!(state.quit, true);
    }
}
#+end_src

#+RESULTS:

** DONE strings [2023-04-01 Sat 01:10]
:LOGBOOK:
CLOCK: [2023-04-01 Sat 01:10]--[2023-04-01 Sat 01:19] =>  0:09
:END:
*** strings1
#+begin_src rust
// strings1.rs
// Make me compile without changing the function signature!
// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.


fn main() {
    let answer = current_favorite_color();
    println!("My current favorite color is {}", answer);
}

fn current_favorite_color() -> String {
    "blue".to_string()
}
#+end_src

#+RESULTS:
: My current favorite color is blue

*** strings2
#+begin_src rust
// strings2.rs
// Make me compile without changing the function signature!
// Execute `rustlings hint strings2` or use the `hint` watch subcommand for a hint.


fn main() {
    let word = String::from("green"); // Try not changing this line :)
    if is_a_color_word(word.as_str()) {
        println!("That is a color word I know!");
    } else {
        println!("That is not a color word I know.");
    }
}

fn is_a_color_word(attempt: &str) -> bool {
    attempt == "green" || attempt == "blue" || attempt == "red"
}
#+end_src

#+RESULTS:
: That is a color word I know!

*** strings3
#+begin_src rust
// strings3.rs
// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.


fn trim_me(input: &str) -> String {
    // TODO: Remove whitespace from both ends of a string!
    input.trim().to_string()
}

fn compose_me(input: &str) -> String {
    // TODO: Add " world!" to the string! There's multiple ways to do this!
    input.to_string() + &String::from(" world!")
}

fn replace_me(input: &str) -> String {
    // TODO: Replace "cars" in the string with "balloons"!
    input.replace("cars", "balloons").to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn trim_a_string() {
        assert_eq!(trim_me("Hello!     "), "Hello!");
        assert_eq!(trim_me("  What's up!"), "What's up!");
        assert_eq!(trim_me("   Hola!  "), "Hola!");
    }

    #[test]
    fn compose_a_string() {
        assert_eq!(compose_me("Hello"), "Hello world!");
        assert_eq!(compose_me("Goodbye"), "Goodbye world!");
    }

    #[test]
    fn replace_a_string() {
        assert_eq!(replace_me("I think cars are cool"), "I think balloons are cool");
        assert_eq!(replace_me("I love to look at cars"), "I love to look at balloons");
    }
}
#+end_src

#+RESULTS:

*** strings4
#+begin_src rust
// strings4.rs

// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your
// task is to call one of these two functions on each value depending on what
// you think each value is. That is, add either `string_slice` or `string`
// before the parentheses on each line. If you're right, it will compile!
// No hints this time!


fn string_slice(arg: &str) {
    println!("{}", arg);
}
fn string(arg: String) {
    println!("{}", arg);
}

fn main() {
    string_slice("blue");
    string("red".to_string());
    string(String::from("hi"));
    string("rust is fun!".to_owned());
    string("nice weather".into());
    string(format!("Interpolation {}", "Station"));
    string_slice(&String::from("abc")[0..1]);
    string_slice("  hello there ".trim());
    string("Happy Monday!".to_string().replace("Mon", "Tues"));
    string("mY sHiFt KeY iS sTiCkY".to_lowercase());
}
#+end_src

#+RESULTS:
#+begin_example
blue
red
hi
rust is fun!
nice weather
Interpolation Station
a
hello there
Happy Tuesday!
my shift key is sticky
#+end_example

** DONE modules [2023-04-01 Sat 01:21]
:LOGBOOK:
CLOCK: [2023-04-01 Sat 01:22]--[2023-04-01 Sat 01:25] =>  0:03
:END:
*** modules1
#+begin_src rust
// modules1.rs
// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.


mod sausage_factory {
    // Don't let anybody outside of this module see this!
    fn get_secret_recipe() -> String {
        String::from("Ginger")
    }

    pub fn make_sausage() {
        get_secret_recipe();
        println!("sausage!");
    }
}

fn main() {
    sausage_factory::make_sausage();
}
#+end_src
*** modules2
#+begin_src rust
// modules2.rs
// You can bring module paths into scopes and provide new names for them with the
// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.
// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.


mod delicious_snacks {
    // TODO: Fix these use statements
    pub use self::fruits::PEAR as fruit;
    pub use self::veggies::CUCUMBER as veggie;

    mod fruits {
        pub const PEAR: &'static str = "Pear";
        pub const APPLE: &'static str = "Apple";
    }

    mod veggies {
        pub const CUCUMBER: &'static str = "Cucumber";
        pub const CARROT: &'static str = "Carrot";
    }
}

fn main() {
    println!(
        "favorite snacks: {} and {}",
        delicious_snacks::fruit,
        delicious_snacks::veggie
    );
}
#+end_src

#+RESULTS:
: favorite snacks: Pear and Cucumber

*** modules3
#+begin_src rust
// modules3.rs
// You can use the 'use' keyword to bring module paths from modules from anywhere
// and especially from the Rust standard library into your scope.
// Bring SystemTime and UNIX_EPOCH
// from the std::time module. Bonus style points if you can do it with one line!
// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.


// TODO: Complete this use statement
use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(n) => println!("1970-01-01 00:00:00 UTC was {} seconds ago!", n.as_secs()),
        Err(_) => panic!("SystemTime before UNIX EPOCH!"),
    }
}
#+end_src

#+RESULTS:
: 1970-01-01 00:00:00 UTC was 1680283607 seconds ago!

** DONE hashmaps [2023-04-01 Sat 01:28]
:LOGBOOK:
CLOCK: [2023-04-01 Sat 01:28]--[2023-04-01 Sat 01:44] =>  0:16
:END:
*** hashmaps1
#+begin_src rust
// hashmaps1.rs
// A basket of fruits in the form of a hash map needs to be defined.
// The key represents the name of the fruit and the value represents
// how many of that particular fruit is in the basket. You have to put
// at least three different types of fruits (e.g apple, banana, mango)
// in the basket and the total count of all the fruits should be at
// least five.
//
// Make me compile and pass the tests!
//
// Execute `rustlings hint hashmaps1` or use the `hint` watch subcommand for a hint.


use std::collections::HashMap;

fn fruit_basket() -> HashMap<String, u32> {
    let mut basket = HashMap::new(); // TODO: declare your hash map here.

    // Two bananas are already given for you :)
    basket.insert(String::from("banana"), 2);

    // TODO: Put more fruits in your basket here.
    basket.insert(String::from("apple"), 3);
    basket.insert(String::from("pineapple"), 3);

    basket
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn at_least_three_types_of_fruits() {
        let basket = fruit_basket();
        assert!(basket.len() >= 3);
    }

    #[test]
    fn at_least_five_fruits() {
        let basket = fruit_basket();
        assert!(basket.values().sum::<u32>() >= 5);
    }
}
#+end_src

#+RESULTS:
*** hashmaps2
#+begin_src rust
// hashmaps2.rs

// A basket of fruits in the form of a hash map is given. The key
// represents the name of the fruit and the value represents how many
// of that particular fruit is in the basket. You have to put *MORE
// THAN 11* fruits in the basket. Three types of fruits - Apple (4),
// Mango (2) and Lychee (5) are already given in the basket. You are
// not allowed to insert any more of these fruits!
//
// Make me pass the tests!
//
// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.


use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
}

fn fruit_basket(basket: &mut HashMap<Fruit, u32>) {
    let fruit_kinds = vec![
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
    ];

    for fruit in fruit_kinds {
        // TODO: Put new fruits if not already present. Note that you
        // are not allowed to put any type of fruit that's already
        // present!
        if !basket.contains_key(&fruit) {
            basket.insert(fruit, 1);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_fruit_basket() -> HashMap<Fruit, u32> {
        let mut basket = HashMap::<Fruit, u32>::new();
        basket.insert(Fruit::Apple, 4);
        basket.insert(Fruit::Mango, 2);
        basket.insert(Fruit::Lychee, 5);

        basket
    }

    #[test]
    fn test_given_fruits_are_not_modified() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);
        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);
        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);
    }

    #[test]
    fn at_least_five_types_of_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        let count_fruit_kinds = basket.len();
        assert!(count_fruit_kinds >= 5);
    }

    #[test]
    fn greater_than_eleven_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        let count = basket.values().sum::<u32>();
        assert!(count > 11);
    }
}
#+end_src

#+RESULTS:

*** hashmaps3
#+begin_src rust
// hashmaps3.rs

// A list of scores (one per line) of a soccer match is given. Each line
// is of the form :
// <team_1_name>,<team_2_name>,<team_1_goals>,<team_2_goals>
// Example: England,France,4,2 (England scored 4 goals, France 2).

// You have to build a scores table containing the name of the team, goals
// the team scored, and goals the team conceded. One approach to build
// the scores table is to use a Hashmap. The solution is partially
// written to use a Hashmap, complete it to pass the test.

// Make me pass the tests!

// Execute `rustlings hint hashmaps3` or use the `hint` watch subcommand for a hint.


use std::collections::HashMap;

// A structure to store team name and its goal details.
struct Team {
    name: String,
    goals_scored: u8,
    goals_conceded: u8,
}

fn build_scores_table(results: String) -> HashMap<String, Team> {
    // The name of the team is the key and its associated struct is the value.
    let mut scores: HashMap<String, Team> = HashMap::new();

    for r in results.lines() {
        let v: Vec<&str> = r.split(',').collect();
        let team_1_name = v[0].to_string();
        let team_1_score: u8 = v[2].parse().unwrap();
        let team_2_name = v[1].to_string();
        let team_2_score: u8 = v[3].parse().unwrap();
        // TODO: Populate the scores table with details extracted from the
        // current line. Keep in mind that goals scored by team_1
        // will be number of goals conceded from team_2, and similarly
        // goals scored by team_2 will be the number of goals conceded by
        // team_1.
        match scores.get(&team_1_name) {
            Some(team1) => scores.insert(
                team_1_name.clone(),
                Team {
                    name: team_1_name.clone(),
                    goals_scored: team_1_score + team1.goals_scored,
                    goals_conceded: team_2_score + team1.goals_conceded,
                },
            ),
            None => scores.insert(
                team_1_name.clone(),
                Team {
                    name: team_1_name.clone(),
                    goals_scored: team_1_score,
                    goals_conceded: team_2_score,
                },
            ),
        };
        match scores.get(&team_2_name) {
            Some(team2) => scores.insert(
                team_2_name.clone(),
                Team {
                    name: team_2_name.clone(),
                    goals_scored: team_2_score + team2.goals_scored,
                    goals_conceded: team_1_score + team2.goals_conceded,
                },
            ),
            None => scores.insert(
                team_2_name.clone(),
                Team {
                    name: team_2_name.clone(),
                    goals_scored: team_2_score,
                    goals_conceded: team_1_score,
                },
            ),
        };
    }
    scores
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_results() -> String {
        let results = "".to_string()
            + "England,France,4,2\n"
            + "France,Italy,3,1\n"
            + "Poland,Spain,2,0\n"
            + "Germany,England,2,1\n";
        results
    }

    #[test]
    fn build_scores() {
        let scores = build_scores_table(get_results());

        let mut keys: Vec<&String> = scores.keys().collect();
        keys.sort();
        assert_eq!(
            keys,
            vec!["England", "France", "Germany", "Italy", "Poland", "Spain"]
        );
    }

    #[test]
    fn validate_team_score_1() {
        let scores = build_scores_table(get_results());
        let team = scores.get("England").unwrap();
        assert_eq!(team.goals_scored, 5);
        assert_eq!(team.goals_conceded, 4);
    }

    #[test]
    fn validate_team_score_2() {
        let scores = build_scores_table(get_results());
        let team = scores.get("Spain").unwrap();
        assert_eq!(team.goals_scored, 0);
        assert_eq!(team.goals_conceded, 2);
    }
}
#+end_src

#+RESULTS:

** DONE quiz2 [2023-04-01 Sat 01:57]
:LOGBOOK:
CLOCK: [2023-04-01 Sat 01:57]--[2023-04-01 Sat 02:15] =>  0:18
:END:
#+begin_src rust
// quiz2.rs
// This is a quiz for the following sections:
// - Strings
// - Vecs
// - Move semantics
// - Modules
// - Enums

// Let's build a little machine in form of a function.
// As input, we're going to give a list of strings and commands. These commands
// determine what action is going to be applied to the string. It can either be:
// - Uppercase the string
// - Trim the string
// - Append "bar" to the string a specified amount of times
// The exact form of this will be:
// - The input is going to be a Vector of a 2-length tuple,
//   the first element is the string, the second one is the command.
// - The output element is going to be a Vector of strings.
// No hints this time!


pub enum Command {
    Uppercase,
    Trim,
    Append(usize),
}

mod my_module {
    use super::Command;

    // TODO: Complete the function signature!
    pub fn transformer(input: Vec<(String, Command)>) -> Vec<String> {
        // TODO: Complete the output declaration!
        let mut output: Vec<String> = vec![];
        for (string, command) in input.iter() {
            // TODO: Complete the function body. You can do it!
            match command {
                Command::Append(cnt) => {
                    let mut s = string.clone();
                    for _ in 0..*cnt as usize {
                        s.push_str("bar");
                    }
                    output.push(s);
                }
                Command::Trim => {
                    output.push(string.trim().to_string());
                }
                Command::Uppercase => {
                    output.push(string.to_uppercase());
                }
            }
        }
        output
    }
}

#[cfg(test)]
mod tests {
    // TODO: What do we have to import to have `transformer` in scope?
    use super::my_module::transformer;
    use super::Command;

    #[test]
    fn it_works() {
        let output = transformer(vec![
            ("hello".into(), Command::Uppercase),
            (" all roads lead to rome! ".into(), Command::Trim),
            ("foo".into(), Command::Append(1)),
            ("bar".into(), Command::Append(5)),
        ]);
        assert_eq!(output[0], "HELLO");
        assert_eq!(output[1], "all roads lead to rome!");
        assert_eq!(output[2], "foobar");
        assert_eq!(output[3], "barbarbarbarbarbar");
    }
}
#+end_src
** TODO options
** TODO errors
** TODO generics
** TODO traits
** TODO quiz3
** TODO tests
** TODO lifetimes
** TODO standard_library_types
** TODO threads
** TODO macros
** TODO clippy
** TODO conversions

* 时间统计 [2023-03-31 Fri 00:37]
| Headline                                        | Time   |   |      |      |
|-------------------------------------------------+--------+---+------+------|
| *Total time*                                    | *2:04* |   |      |      |
|-------------------------------------------------+--------+---+------+------|
| \_    实验记录 [2023-03-31 Fri 00:29]           |        |   | 2:04 |      |
| \_      环境准备 [2023-03-31 Fri 00:29]         |        |   |      | 0:22 |
| \_      intro [2023-03-31 Fri 23:29]           |        |   |      | 0:05 |
| \_      variables [2023-03-31 Fri 00:36]       |        |   |      | 0:05 |
| \_      functions [2023-03-31 Fri 23:49]       |        |   |      | 0:06 |
| \_      if [2023-04-01 Sat 00:01]              |        |   |      | 0:03 |
| \_      quiz1 [2023-04-01 Sat 00:05]           |        |   |      | 0:03 |
| \_      primitive_types [2023-04-01 Sat 00:09] |        |   |      | 0:05 |
| \_      vecs [2023-04-01 Sat 00:18]            |        |   |      | 0:02 |
| \_      move_semantics [2023-04-01 Sat 00:23]  |        |   |      | 0:09 |
| \_      structs [2023-04-01 Sat 00:35]         |        |   |      | 0:11 |
| \_      enums [2023-04-01 Sat 00:58]           |        |   |      | 0:07 |
| \_      strings [2023-04-01 Sat 01:10]         |        |   |      | 0:09 |
| \_      modules [2023-04-01 Sat 01:21]         |        |   |      | 0:03 |
| \_      hashmaps [2023-04-01 Sat 01:28]        |        |   |      | 0:16 |
| \_      quiz2 [2023-04-01 Sat 01:57]           |        |   |      | 0:18 |
